// set up a simple neutral simulation
initialize() {
	initializeMutationRate(1e-7);
	
	// m1 mutation type: liabillity increasing 
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	//QUESTION: SHOULD I HAVE PROTECTIVE MUTATIONS
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	m1.convertToSubstitution=T;
	
	L = 100000;
	
	// uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, L);
	initializeRecombinationRate(1e-5);

	
	defineConstant("selec",0.3); //fitness cost of disease
	defineConstant("h2", 0.5); //heritability
	defineConstant("init_pop", 5000);//initial population size
	defineConstant("mu", (1e-7)); //mutations per base position
	defineConstant("rho", 0); //percent of protective mutations
	defineConstant("gamma", log(rho / (1-rho)));
	defineConstant("s", gamma/ (4 * init_pop));
	defineConstant("stdev", sqrt(4* L * mu/s * (exp(gamma)-1)/(exp(gamma)+1)));
	defineConstant("equilibrium", L *((4 * init_pop * mu) / ((4 * init_pop * mu) + 1)));
	
}


// create a population of 500 individuals
1 {
	sim.addSubpop("p1", init_pop);
	
	//use sim.tag to store the boolean of whether the threshold has been turned on or not
	sim.tag = F;
	
	//use
	y = matrix(rep(0,200), nrow=2);

}


1:late() {

	// sum the additive effects of QTLs
	inds = sim.subpopulations.individuals;
	
   genLi = asFloat(inds.countOfMutationsOfType(m1) + sum(sim.substitutions.mutationType == m1));
   V_A = var(genLi);
   inds.tagF = genLi;
	
			
	//if the thresold has not been turned on 
	if (!sim.tag) {
		
		//if it has reached 95% of equilibirum genetic liability, turn on the threshold
		if (V_A >= (equilibrium * 0.95)) {
		
			print(paste("reached equilibrium at generation " + asString(sim.generation)));
	
			//calculate the threshold value
			t = 2 * (max(inds.tagF) - mean(inds.tagF));
			defineConstant("thres", t);
			defineConstant("thresOnGen" , sim.generation);
			sim.tag = T;
			print(paste("threshold set to " + thres));
			
			defineConstant("out", asString(10000) + "_" + asString(t) + "_ms.txt");
		}
	
	//if not, then the threshold is turned on
	} else {
	
		//write the genetic variance to a file every generation.
		//writeFile("genetic_variance.txt", paste(V_A), append=T);
		
		//CALCULATE SEG SITES
		seg_sites = sortBy(unique(sim.subpopulations.genomes.mutations), "position");
		
		//OUTPUT GENETIC VARIANCE, MEAN LIAB, NUM SEG SITES
		writeFile("simulation.txt", paste(V_A + " " + mean(inds.tagF)+ " " + size(seg_sites)), append=T);
		
		//Every 5000 generations read the file
		if ((sim.generation % 5000) == 0) {
			variation = readFile("genetic_variance.txt");
			
			//if reading is unsuccesful raise error
			read_success = deleteFile("genetic_variance.txt");
				if (!read_success) {
					print("Oops error deleting file");}
					
			variation = asFloat(variation);		
			time = seq(1,size(variation));
			
			slope = cov(variation, time) / var(time);
			print(slope);
			writeFile("slope.txt", paste(slope), append=T);
		
		}
			
		
		
		//TODO: figure out when the genetic variance reaches equilibrium again and output the 	population state + the genetic variance
		//if ( ) {
			//p1.outputMSSample(2 * init_pop, replace=F, out); 
		//}
	
	}
	
					
		//writeFile(out, test_line, append=T);	
} 

fitness(NULL){
	
	//if the threshold has been turned on, add the fitness cost of disease if an individual is past 	the threshold
	if (sim.tag) {
	
		return 1.0 - selec * asFloat(individual.tagF>thres);
		
	} else {
	
		return 1.0;
		
	}
}


//End simulation at generation 70000
200000 {
	sim.simulationFinished();
}